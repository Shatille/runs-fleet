name: Build Orchestrator Image

on:
  workflow_dispatch:
    inputs:
      bump:
        description: "Version bump type"
        type: choice
        options: [patch, minor]
        default: patch
      custom_version:
        description: "Custom version (e.g., v1.2.0). Overrides bump type."
        type: string
  workflow_call:
    inputs:
      bump:
        description: "Version bump type"
        type: string
        default: "patch"
      custom_version:
        description: "Custom version"
        type: string
    secrets:
      AWS_IAM_ROLE_ARN:
        required: true
    outputs:
      version:
        description: "Built image version"
        value: ${{ jobs.manifest.outputs.version }}

permissions:
  contents: read
  id-token: write

env:
  AWS_REGION: ap-northeast-1
  ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY || 'runs-fleet' }}

jobs:
  version:
    name: Calculate Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.new_version }}
    steps:
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_IAM_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Calculate version
        id: version
        run: |
          validate_version() {
            if ! [[ $1 =~ ^v?[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "Invalid version format '$1'"
              exit 1
            fi
          }

          CUSTOM="${{ inputs.custom_version }}"
          if [ -n "$CUSTOM" ]; then
            validate_version "$CUSTOM"
            [[ $CUSTOM =~ ^v ]] || CUSTOM="v${CUSTOM}"
            NEW_VERSION="$CUSTOM"
          else
            LATEST=$(aws ecr describe-images --repository-name $ECR_REPOSITORY \
              --query 'imageDetails[*].imageTags[]' --output text 2>/dev/null | \
              tr '\t' '\n' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -n1)

            VERSION=${LATEST#v}
            if [ -z "$VERSION" ]; then
              VERSION="0.0.0"
            fi
            MAJOR=$(echo $VERSION | cut -d. -f1)
            MINOR=$(echo $VERSION | cut -d. -f2)
            PATCH=$(echo $VERSION | cut -d. -f3)

            BUMP="${{ inputs.bump || 'patch' }}"
            if [ "$BUMP" = "minor" ]; then
              NEW_VERSION="v${MAJOR}.$((MINOR + 1)).0"
            else
              NEW_VERSION="v${MAJOR}.${MINOR}.$((PATCH + 1))"
            fi
          fi

          if aws ecr describe-images --repository-name $ECR_REPOSITORY \
            --image-ids imageTag=$NEW_VERSION >/dev/null 2>&1; then
            echo "Version $NEW_VERSION already exists"
            exit 1
          fi

          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Version: $NEW_VERSION"

  build:
    name: Build ${{ matrix.arch }}
    needs: version
    runs-on: "${{ matrix.runner }}"
    strategy:
      fail-fast: true
      matrix:
        include:
          - arch: amd64
            runner: ubuntu-latest
            platform: linux/amd64
          - arch: arm64
            runner: runs-fleet=${{ github.run_id }}/cpu=4/arch=arm64
            platform: linux/arm64
    steps:
      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_IAM_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - uses: aws-actions/amazon-ecr-login@v2
        id: ecr

      - uses: docker/setup-buildx-action@v3

      - name: Build and push
        uses: docker/build-push-action@v6
        env:
          ECR_REGISTRY: ${{ steps.ecr.outputs.registry }}
          VERSION: ${{ needs.version.outputs.version }}
        with:
          context: .
          file: Dockerfile
          platforms: ${{ matrix.platform }}
          push: true
          pull: true
          tags: ${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.version.outputs.version }}-${{ matrix.arch }}
          build-args: |
            VERSION=${{ needs.version.outputs.version }}
          cache-from: type=registry,ref=${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:cache-${{ matrix.arch }}
          cache-to: type=registry,ref=${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:cache-${{ matrix.arch }},mode=max,image-manifest=true
          provenance: false
          no-cache-filters: stage-1

  manifest:
    name: Create Manifest
    needs: [version, build]
    runs-on: ubuntu-latest
    outputs:
      version: ${{ needs.version.outputs.version }}
    steps:
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_IAM_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - uses: aws-actions/amazon-ecr-login@v2
        id: ecr

      - name: Create and push manifest
        env:
          ECR_REGISTRY: ${{ steps.ecr.outputs.registry }}
          VERSION: ${{ needs.version.outputs.version }}
        run: |
          docker manifest create $ECR_REGISTRY/$ECR_REPOSITORY:$VERSION \
            $ECR_REGISTRY/$ECR_REPOSITORY:$VERSION-amd64 \
            $ECR_REGISTRY/$ECR_REPOSITORY:$VERSION-arm64

          docker manifest create $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            $ECR_REGISTRY/$ECR_REPOSITORY:$VERSION-amd64 \
            $ECR_REGISTRY/$ECR_REPOSITORY:$VERSION-arm64

          docker manifest push $ECR_REGISTRY/$ECR_REPOSITORY:$VERSION
          docker manifest push $ECR_REGISTRY/$ECR_REPOSITORY:latest

      - name: Summary
        env:
          VERSION: ${{ needs.version.outputs.version }}
          ECR_REGISTRY: ${{ steps.ecr.outputs.registry }}
        run: |
          echo "### Built $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "- Image: \`$ECR_REGISTRY/$ECR_REPOSITORY:$VERSION\`" >> $GITHUB_STEP_SUMMARY
          echo "- Platforms: linux/amd64, linux/arm64" >> $GITHUB_STEP_SUMMARY
