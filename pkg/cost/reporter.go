// Package cost provides cost reporting functionality for runs-fleet.
package cost

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"log/slog"
	"time"

	"github.com/Shavakan/runs-fleet/pkg/config"
	"github.com/Shavakan/runs-fleet/pkg/logging"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/cloudwatch"
	cwtypes "github.com/aws/aws-sdk-go-v2/service/cloudwatch/types"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"github.com/aws/aws-sdk-go-v2/service/sns"
)

var costLog = logging.WithComponent(logging.LogTypeCost, "reporter")

// Pricing constants (approximate AWS pricing in USD)
//
// WARNING: COST ESTIMATES ONLY - NOT FOR BILLING OR FINANCIAL DECISIONS
//
// These prices are hard-coded estimates based on us-east-1 on-demand pricing as of 2024.
// Limitations:
//   - Prices become outdated as AWS adjusts pricing
//   - Does not account for regional price variations
//   - Does not include data transfer, EBS, or other ancillary costs
//   - Spot pricing is estimated as a fixed discount, not actual spot prices
//
// For accurate cost tracking, integrate with:
//   - AWS Cost Explorer API: https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/ce-api.html
//   - AWS Pricing API: https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/price-changes.html
//
// The reports generated by this package should be used for trending and relative
// comparison only, not for actual billing or financial planning.
var instancePricing = map[string]float64{
	// On-demand prices (per hour, us-east-1, approximate)
	"t4g.micro":   0.0084,
	"t4g.small":   0.0168,
	"t4g.medium":  0.0336,
	"t4g.large":   0.0672,
	"t4g.xlarge":  0.1344,
	"t4g.2xlarge": 0.2688,
	"c7g.medium":  0.0361,
	"c7g.large":   0.0725,
	"c7g.xlarge":  0.1450,
	"c7g.2xlarge": 0.2900,
	"m7g.medium":  0.0408,
	"m7g.large":   0.0816,
	"m7g.xlarge":  0.1632,
	"m7g.2xlarge": 0.3264,
}

// SpotDiscount is the average spot discount compared to on-demand
const SpotDiscount = 0.7 // 70% discount

// CloudWatchAPI defines CloudWatch operations for cost reporting.
type CloudWatchAPI interface {
	GetMetricData(ctx context.Context, params *cloudwatch.GetMetricDataInput, optFns ...func(*cloudwatch.Options)) (*cloudwatch.GetMetricDataOutput, error)
}

// S3API defines S3 operations for storing reports.
type S3API interface {
	PutObject(ctx context.Context, params *s3.PutObjectInput, optFns ...func(*s3.Options)) (*s3.PutObjectOutput, error)
}

// SNSAPI defines SNS operations for sending notifications.
type SNSAPI interface {
	Publish(ctx context.Context, params *sns.PublishInput, optFns ...func(*sns.Options)) (*sns.PublishOutput, error)
}

// Breakdown represents cost breakdown by service.
type Breakdown struct {
	Date              string
	TotalCost         float64
	EC2SpotCost       float64
	EC2OnDemandCost   float64
	EC2SpotHours      float64
	EC2OnDemandHours  float64
	SpotSavings       float64
	S3Cost            float64
	FargateCost       float64
	SQSCost           float64
	DynamoDBCost      float64
	CloudWatchCost    float64
	JobsCompleted     int
	SpotInterruptions int
	CacheHitRate      float64
}

// Reporter generates daily cost reports.
type Reporter struct {
	cwClient      CloudWatchAPI
	s3Client      S3API
	snsClient     SNSAPI
	priceFetcher  PriceFetcherAPI
	config        *config.Config
	snsTopicARN   string
	reportsBucket string
}

// PriceFetcherAPI defines the interface for fetching instance prices.
type PriceFetcherAPI interface {
	GetPrice(ctx context.Context, instanceType string) (float64, error)
}

// NewReporter creates a new cost reporter.
// It initializes a PriceFetcher to attempt dynamic pricing lookups from AWS Pricing API.
func NewReporter(cfg aws.Config, appConfig *config.Config, snsTopicARN, reportsBucket string) *Reporter {
	return &Reporter{
		cwClient:      cloudwatch.NewFromConfig(cfg),
		s3Client:      s3.NewFromConfig(cfg),
		snsClient:     sns.NewFromConfig(cfg),
		priceFetcher:  NewPriceFetcher(cfg, cfg.Region),
		config:        appConfig,
		snsTopicARN:   snsTopicARN,
		reportsBucket: reportsBucket,
	}
}

// NewReporterWithClients creates a new cost reporter with injected clients for testing.
func NewReporterWithClients(cwClient CloudWatchAPI, s3Client S3API, snsClient SNSAPI, priceFetcher PriceFetcherAPI, appConfig *config.Config, snsTopicARN, reportsBucket string) *Reporter {
	return &Reporter{
		cwClient:      cwClient,
		s3Client:      s3Client,
		snsClient:     snsClient,
		priceFetcher:  priceFetcher,
		config:        appConfig,
		snsTopicARN:   snsTopicARN,
		reportsBucket: reportsBucket,
	}
}

// GenerateDailyReport generates the daily cost report.
// It attempts to fetch current prices from AWS Pricing API and falls back to
// hard-coded estimates if the API is unavailable.
func (r *Reporter) GenerateDailyReport(ctx context.Context) error {
	costLog.Info("generating daily cost report")

	endTime := time.Now().Truncate(time.Hour)
	startTime := endTime.Add(-24 * time.Hour)

	breakdown, err := r.getCostMetrics(ctx, startTime, endTime)
	if err != nil {
		return fmt.Errorf("failed to get cost metrics: %w", err)
	}

	breakdown.Date = startTime.Format("2006-01-02")

	report := r.generateMarkdownReport(breakdown)

	if r.reportsBucket != "" {
		key := fmt.Sprintf("cost/%s/%s/%s.md",
			startTime.Format("2006"),
			startTime.Format("01"),
			startTime.Format("02"))

		_, err = r.s3Client.PutObject(ctx, &s3.PutObjectInput{
			Bucket:      aws.String(r.reportsBucket),
			Key:         aws.String(key),
			Body:        io.NopCloser(bytes.NewReader([]byte(report))),
			ContentType: aws.String("text/markdown"),
		})
		if err != nil {
			costLog.Warn("s3 report upload failed", slog.String("error", err.Error()))
		} else {
			costLog.Info("report stored in s3", slog.String("bucket", r.reportsBucket), slog.String("key", key))
		}
	}

	if r.snsTopicARN != "" {
		_, err = r.snsClient.Publish(ctx, &sns.PublishInput{
			TopicArn: aws.String(r.snsTopicARN),
			Subject:  aws.String(fmt.Sprintf("runs-fleet Daily Cost Report - %s", breakdown.Date)),
			Message:  aws.String(report),
		})
		if err != nil {
			costLog.Warn("sns notification failed", slog.String("error", err.Error()))
		} else {
			costLog.Info("report sent via sns")
		}
	}

	costLog.Info("daily cost report generated", slog.Float64("total_cost", breakdown.TotalCost))
	return nil
}

// getCostMetrics retrieves cost-related metrics from CloudWatch.
func (r *Reporter) getCostMetrics(ctx context.Context, startTime, endTime time.Time) (*Breakdown, error) {
	breakdown := &Breakdown{}

	queries := []cwtypes.MetricDataQuery{
		{
			Id: aws.String("fleet_size_increment"),
			MetricStat: &cwtypes.MetricStat{
				Metric: &cwtypes.Metric{
					Namespace:  aws.String("RunsFleet"),
					MetricName: aws.String("FleetSizeIncrement"),
				},
				Period: aws.Int32(3600),
				Stat:   aws.String("Sum"),
			},
		},
		{
			Id: aws.String("spot_interruptions"),
			MetricStat: &cwtypes.MetricStat{
				Metric: &cwtypes.Metric{
					Namespace:  aws.String("RunsFleet"),
					MetricName: aws.String("SpotInterruptions"),
				},
				Period: aws.Int32(3600),
				Stat:   aws.String("Sum"),
			},
		},
		{
			Id: aws.String("job_success"),
			MetricStat: &cwtypes.MetricStat{
				Metric: &cwtypes.Metric{
					Namespace:  aws.String("RunsFleet"),
					MetricName: aws.String("JobSuccess"),
				},
				Period: aws.Int32(3600),
				Stat:   aws.String("Sum"),
			},
		},
		{
			Id: aws.String("job_failure"),
			MetricStat: &cwtypes.MetricStat{
				Metric: &cwtypes.Metric{
					Namespace:  aws.String("RunsFleet"),
					MetricName: aws.String("JobFailure"),
				},
				Period: aws.Int32(3600),
				Stat:   aws.String("Sum"),
			},
		},
		{
			Id: aws.String("job_duration"),
			MetricStat: &cwtypes.MetricStat{
				Metric: &cwtypes.Metric{
					Namespace:  aws.String("RunsFleet"),
					MetricName: aws.String("JobDuration"),
				},
				Period: aws.Int32(3600),
				Stat:   aws.String("Sum"),
			},
		},
	}

	output, err := r.cwClient.GetMetricData(ctx, &cloudwatch.GetMetricDataInput{
		StartTime:         aws.Time(startTime),
		EndTime:           aws.Time(endTime),
		MetricDataQueries: queries,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get metric data: %w", err)
	}

	var totalInstances, spotInterruptions, jobSuccess, jobFailure float64
	var totalJobDurationSeconds float64

	for _, result := range output.MetricDataResults {
		sum := 0.0
		for _, value := range result.Values {
			sum += value
		}

		switch *result.Id {
		case "fleet_size_increment":
			totalInstances = sum
		case "spot_interruptions":
			spotInterruptions = sum
		case "job_success":
			jobSuccess = sum
		case "job_failure":
			jobFailure = sum
		case "job_duration":
			totalJobDurationSeconds = sum
		}
	}

	// Estimate average job duration in hours
	totalJobs := jobSuccess + jobFailure
	avgJobHours := 0.5 // Default 30 min if no data
	if totalJobs > 0 && totalJobDurationSeconds > 0 {
		avgJobHours = (totalJobDurationSeconds / totalJobs) / 3600
	}

	// Estimate spot vs on-demand split (assume 80% spot, 20% on-demand)
	spotInstances := totalInstances * 0.8
	onDemandInstances := totalInstances * 0.2

	// Calculate instance hours
	breakdown.EC2SpotHours = spotInstances * avgJobHours
	breakdown.EC2OnDemandHours = onDemandInstances * avgJobHours

	// Use average instance cost (t4g.medium as default)
	// Try to get dynamic pricing from AWS Pricing API, fall back to hard-coded
	avgHourlyCost, err := r.priceFetcher.GetPrice(ctx, "t4g.medium")
	if err != nil || avgHourlyCost == 0 {
		avgHourlyCost = 0.0336
	}

	breakdown.EC2SpotCost = breakdown.EC2SpotHours * avgHourlyCost * (1 - SpotDiscount)
	breakdown.EC2OnDemandCost = breakdown.EC2OnDemandHours * avgHourlyCost
	breakdown.SpotSavings = breakdown.EC2SpotHours * avgHourlyCost * SpotDiscount

	// Estimate supporting service costs
	// Fargate: ~$1.20/day for 1 vCPU, 2GB
	breakdown.FargateCost = 1.20

	// SQS: ~$0.40 per million requests
	estimatedSQSRequests := (totalInstances * 10) + 1000 // Instance creates + polling
	breakdown.SQSCost = (estimatedSQSRequests / 1000000) * 0.40

	// DynamoDB: PAY_PER_REQUEST, ~$1.25 per million writes, $0.25 per million reads
	estimatedWrites := totalInstances * 3 // Create, update, complete
	estimatedReads := totalInstances * 5  // Queue lookups, status checks
	breakdown.DynamoDBCost = (estimatedWrites/1000000)*1.25 + (estimatedReads/1000000)*0.25

	// CloudWatch: Logs ~$0.50/GB, metrics minimal
	estimatedLogGB := totalInstances * 0.001 // ~1MB per job
	breakdown.CloudWatchCost = estimatedLogGB * 0.50

	// S3: Storage and requests (minimal for cache)
	breakdown.S3Cost = 0.05 // Estimate

	breakdown.TotalCost = breakdown.EC2SpotCost + breakdown.EC2OnDemandCost +
		breakdown.FargateCost + breakdown.SQSCost + breakdown.DynamoDBCost +
		breakdown.CloudWatchCost + breakdown.S3Cost

	breakdown.JobsCompleted = int(totalJobs)
	breakdown.SpotInterruptions = int(spotInterruptions)

	return breakdown, nil
}

// generateMarkdownReport generates a markdown report from the cost breakdown.
func (r *Reporter) generateMarkdownReport(b *Breakdown) string {
	var buf bytes.Buffer

	buf.WriteString("# runs-fleet Daily Cost Report\n\n")
	buf.WriteString(fmt.Sprintf("**Date:** %s\n\n", b.Date))
	buf.WriteString(fmt.Sprintf("**24-Hour Total:** $%.2f\n\n", b.TotalCost))

	buf.WriteString("## EC2 Compute\n\n")
	buf.WriteString(fmt.Sprintf("- Spot instances: $%.2f (%.1f instance-hours)\n", b.EC2SpotCost, b.EC2SpotHours))
	buf.WriteString(fmt.Sprintf("- On-demand instances: $%.2f (%.1f instance-hours)\n", b.EC2OnDemandCost, b.EC2OnDemandHours))
	buf.WriteString(fmt.Sprintf("- **Spot savings:** $%.2f (%.0f%% discount)\n\n", b.SpotSavings, SpotDiscount*100))

	buf.WriteString("## Supporting Services\n\n")
	buf.WriteString(fmt.Sprintf("- Fargate orchestrator: $%.2f\n", b.FargateCost))
	buf.WriteString(fmt.Sprintf("- SQS: $%.2f\n", b.SQSCost))
	buf.WriteString(fmt.Sprintf("- DynamoDB: $%.2f\n", b.DynamoDBCost))
	buf.WriteString(fmt.Sprintf("- CloudWatch: $%.2f\n", b.CloudWatchCost))
	buf.WriteString(fmt.Sprintf("- S3: $%.2f\n\n", b.S3Cost))

	buf.WriteString("## Job Statistics\n\n")
	buf.WriteString(fmt.Sprintf("- Jobs completed: %d\n", b.JobsCompleted))
	buf.WriteString(fmt.Sprintf("- Spot interruptions: %d\n", b.SpotInterruptions))
	if b.JobsCompleted > 0 {
		costPerJob := b.TotalCost / float64(b.JobsCompleted)
		buf.WriteString(fmt.Sprintf("- Cost per job: $%.4f\n", costPerJob))
	}

	buf.WriteString("\n---\n")
	buf.WriteString("⚠️ **DISCLAIMER:** These costs are *estimates* based on hard-coded pricing data.\n")
	buf.WriteString("Actual AWS costs may vary. Use AWS Cost Explorer for accurate billing data.\n\n")
	buf.WriteString("*Report generated by runs-fleet*\n")

	return buf.String()
}
